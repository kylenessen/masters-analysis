---
title: "Butterfly Abundance Index"
format:
  html:
    toc: true
    number-sections: false
execute:
  echo: true
  warning: false
  message: false
---

```{r}
#| label: setup
#| include: true
library(jsonlite)
library(dplyr)
library(purrr)
library(tidyr)
library(stringr)
library(tibble)
library(ggplot2)
library(lubridate)

deploy_dir <- "data/deployments"
json_files <- list.files(deploy_dir, pattern = "\\.json$", full.names = TRUE)

# Null-coalescing helper
or_else <- function(x, default) {
  if (is.null(x)) default else x
}

# Map a count value to conservative minimum for its category
count_min_value <- function(x) {
  # Handle NULLs
  if (is.null(x)) return(NA_real_)
  # If numeric, return as-is
  if (is.numeric(x)) return(as.numeric(x))
  # If logical NA
  if (is.na(x)) return(NA_real_)
  # Coerce to character
  xc <- as.character(x)
  xc <- str_trim(xc)
  if (xc == "") return(NA_real_)
  # Exact zero
  if (xc == "0") return(0)
  # Range like "1-9" or "10-99" or "100-999"
  m <- str_match(xc, "^(\\d+)-(\\d+)$")
  if (!anyNA(m)) return(as.numeric(m[2]))
  # "1000+" style
  m2 <- str_match(xc, "^(\\d+)\\+$")
  if (!anyNA(m2)) return(as.numeric(m2[2]))
  # Fallback: try numeric coercion
  suppressWarnings({
    n <- as.numeric(xc)
  })
  if (!is.na(n)) return(n)
  NA_real_
}

extract_cells_df <- function(cells) {
  if (is.null(cells) || length(cells) == 0) return(tibble())
  # cells is a named list of cell_ij -> list(count=..., directSun/sunlight=...)
  keys <- names(cells)
  vals <- cells
  tibble(
    cell = keys,
    count_raw = map(vals, ~ or_else(.x[["count"]], NA)),
    direct_sun = map_lgl(vals, function(.x) {
      # Prefer directSun; fall back to sunlight; default FALSE if missing
      if (!is.null(.x[["directSun"]])) {
        isTRUE(.x[["directSun"]])
      } else if (!is.null(.x[["sunlight"]])) {
        isTRUE(.x[["sunlight"]])
      } else {
        FALSE
      }
    })
  ) %>%
    mutate(
      count_min = map_dbl(count_raw, count_min_value)
    )
}

parse_deployment <- function(file) {
  # deployment_id is the filename without extension
  deployment_id <- tools::file_path_sans_ext(basename(file))
  x <- jsonlite::read_json(file, simplifyVector = FALSE)

  # Determine structure: either top-level has 'classifications' or the top-level itself maps images
  if (is.list(x) && !is.null(x$classifications)) {
    # Newer structure: possibly includes rows/columns and classifications
    cls <- x$classifications
  } else {
    # Older structure: top-level keys are image filenames
    cls <- x
  }

  # Ensure we have named list of images -> objects with cells
  if (length(cls) == 0) {
    return(tibble(
      deployment_id = deployment_id,
      image_filename = NA_character_,
      total_butterflies = NA_real_,
      butterflies_direct_sun = NA_real_
    ))
  }

  im_names <- names(cls)
  res <- map2_dfr(cls, im_names, function(im_obj, im_name) {
    # Exclude frames explicitly marked as night in newer JSONs
    if (isTRUE(or_else(im_obj[["isNight"]], FALSE))) {
      return(tibble(
        deployment_id = character(0),
        image_filename = character(0),
        total_butterflies = double(0),
        butterflies_direct_sun = double(0)
      ))
    }
    cells <- or_else(im_obj$cells, NULL)
    df <- extract_cells_df(cells)
    if (nrow(df) == 0) {
      tibble(
        deployment_id = deployment_id,
        image_filename = im_name,
        total_butterflies = NA_real_,
        butterflies_direct_sun = NA_real_
      )
    } else {
      tibble(
        deployment_id = deployment_id,
        image_filename = im_name,
        total_butterflies = sum(df$count_min, na.rm = TRUE),
        butterflies_direct_sun = sum(df$count_min[df$direct_sun], na.rm = TRUE)
      )
    }
  })

  res
}

# Parse all deployments
abundance_index <- map_dfr(json_files, function(f) {
  tryCatch(parse_deployment(f), error = function(e) {
    warning(sprintf("Failed to parse %s: %s", f, conditionMessage(e)))
    tibble(
      deployment_id = tools::file_path_sans_ext(basename(f)),
      image_filename = NA_character_,
      total_butterflies = NA_real_,
      butterflies_direct_sun = NA_real_
    )
  })
}) %>%
  arrange(deployment_id, image_filename)

abundance_index

# SC1/SC2 adjustments:
# - Exclude known night intervals (these deployments lack isNight flags)
# - Downsample from 5-minute cadence to 30-minute cadence to match others

# Night intervals provided by user for SC1 and SC2
night_periods <- list(
  SC1 = list(
    list(start = "20231117174001", end = "20231118062001"),
    list(start = "20231118172501", end = "20231119061501"),
    list(start = "20231119171001", end = "20231120062001")
  ),
  SC2 = list(
    list(start = "20231117172501", end = "20231118062001"),
    list(start = "20231118171501", end = "20231119061501")
  )
)

parse_ts <- function(s) as.POSIXct(strptime(s, "%Y%m%d%H%M%S", tz = "UTC"))

sc_is_night <- function(id, ts) {
  if (is.na(ts)) return(FALSE)
  if (!(id %in% names(night_periods))) return(FALSE)
  periods <- night_periods[[id]]
  any(purrr::map_lgl(periods, function(p) {
    ts >= parse_ts(p$start) & ts <= parse_ts(p$end)
  }))
}

abundance_index_filtered <- abundance_index %>%
  mutate(
    timestamp_str = stringr::str_match(tidyr::replace_na(image_filename, ""), ".*_(\\d{14})")[, 2],
    timestamp = parse_ts(timestamp_str)
  ) %>%
  filter(!is.na(timestamp)) %>%
  # Exclude SC1/SC2 frames that fall in known night intervals
  filter(!(deployment_id %in% c("SC1", "SC2") & purrr::map2_lgl(deployment_id, timestamp, sc_is_night))) %>%
  # Downsample SC1/SC2 from 5-min to 30-min by keeping minutes 00 or 30
  filter(!(deployment_id %in% c("SC1", "SC2") & (lubridate::minute(timestamp) %% 30 != 0)))
```

```{r}
#| label: print-summary
#| echo: false
library(knitr)
knitr::kable(head(abundance_index_filtered, 20), caption = "First 20 rows (night-excluded, 30-min SC1/SC2)")
```

```{r}
#| label: plot-timeseries
# Use the filtered dataset with computed timestamps
abundance_index_ts <- abundance_index_filtered

ggplot(abundance_index_ts, aes(x = timestamp, y = total_butterflies)) +
  geom_line() +
  geom_point(size = 0.7) +
  facet_wrap(~ deployment_id, scales = "free_x") +
  labs(
    title = "Butterfly abundance timeseries by deployment",
    x = "Timestamp",
    y = "Total butterflies"
  ) +
  theme_minimal()
```

```{r}
#| label: save-csv
#| eval: false
# Optionally save to CSV for downstream analyses
readr::write_csv(abundance_index_filtered, "data/butterfly_abundance_index.csv")
```

```{r}
#| label: methods-note
cat("Abundance index computed using conservative category minima: 1 for '1-9', 10 for '10-99', 100 for '100-999', and lower bound for any 'N+' values.")
```
