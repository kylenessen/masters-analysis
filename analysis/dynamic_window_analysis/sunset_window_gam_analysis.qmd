---
title: "Dynamic Window GAM Analysis: Sunset Window (Max Count → Functional Sunset)"
author: "Kyle Nessen"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-depth: 3
    toc-location: left
    number-sections: true
    embed-resources: true
    theme: cosmo
    code-fold: true
    code-tools: false
execute:
  warning: false
  message: false
  echo: true
  cache: false
---

## Background and Rationale

This analysis addresses feedback from Francis regarding the temporal alignment of weather predictors with butterfly responses. The [original daily-level analysis](../../reports/daily_gam_results.html) used fixed 6am-6pm weather windows, which Francis identified as having a temporal logic issue:

> "All of the metrics for wind, temperature and light, would need to be re-calculated for 24 hour periods that begin at the time of the highest count."

### Francis's Key Points

1. **Temporal alignment**: Butterflies can only respond to weather *after* it occurs
2. **Biological timing**: If max count occurred at 2pm on day t-1, the relevant weather window should start at 2pm, not 6am
3. **Roosting decisions**: Weather from max count through sunset determines whether butterflies abandon the roost

### This Analysis

**Weather window**: `time_of_max_count_t_1` → `last_observation_time_t` (functional sunset)

- Weather metrics now include **overnight conditions** (24/7 temperature and wind)
- Window lengths vary by observation (mean: 29.6 hours, range: 22.5-34.9 hours)
- Captures weather exposure until roosting decisions are finalized at dusk
- Tests the hypothesis: "Do weather conditions from peak count to sunset predict roost abandonment?"

**Data source**: `data/monarch_daily_lag_analysis_sunset_window.csv` (103 lag pairs)

---

## Setup

```{r setup}
library(tidyverse)
library(mgcv)
library(knitr)
library(here)
library(corrplot)
library(patchwork)
library(gratia)

# Load the sunset window data
daily_data <- read_csv(here("data", "monarch_daily_lag_analysis_sunset_window.csv"))

# Create the square root transformed response variable
daily_data <- daily_data %>%
    mutate(
        butterfly_diff_95th_sqrt = ifelse(butterfly_diff_95th >= 0,
            sqrt(butterfly_diff_95th),
            -sqrt(-butterfly_diff_95th)
        )
    )
```

## Data Overview

```{r data-summary}
cat("Dataset dimensions:", nrow(daily_data), "rows x", ncol(daily_data), "columns\n")
cat("Number of deployments:", n_distinct(daily_data$deployment_id), "\n")
cat("Date range:", min(daily_data$date_t), "to", max(daily_data$date_t), "\n\n")

cat("Window characteristics:\n")
cat("- Mean lag duration:", round(mean(daily_data$lag_duration_hours, na.rm = TRUE), 2), "hours\n")
cat(
    "- Duration range:", round(min(daily_data$lag_duration_hours, na.rm = TRUE), 2), "-",
    round(max(daily_data$lag_duration_hours, na.rm = TRUE), 2), "hours\n"
)
cat("- Median data completeness:", round(median(daily_data$metrics_complete, na.rm = TRUE), 3), "\n\n")

# Summary of key variables
summary_vars <- daily_data %>%
    select(
        butterflies_95th_percentile_t,
        butterflies_95th_percentile_t_1,
        butterfly_diff_95th,
        temp_max,
        temp_min,
        temp_at_max_count_t_1,
        wind_max_gust,
        sum_butterflies_direct_sun,
        lag_duration_hours,
        metrics_complete
    )

kable(summary(summary_vars), caption = "Summary statistics for key variables")
```

## Response Variable Selection

We evaluate three butterfly difference metrics (max, 95th percentile, and top 3 mean) with three transformations each (untransformed, square root, and square) to determine which best approximates normality.

```{r response-normality, fig.width=12, fig.height=10}
# Filter to complete data for consistency with modeling
data_filtered <- daily_data %>% filter(metrics_complete >= 0.95)

# Define response variables
response_vars <- c(
    "butterfly_diff", "butterfly_diff_sqrt", "butterfly_diff_sq",
    "butterfly_diff_95th", "butterfly_diff_95th_sqrt", "butterfly_diff_95th_sq",
    "butterfly_diff_top3", "butterfly_diff_top3_sqrt", "butterfly_diff_top3_sq"
)

# Calculate Shapiro-Wilk tests
normality_tests <- tibble(
    variable = response_vars,
    shapiro_stat = NA_real_,
    p_value = NA_real_,
    skewness = NA_real_,
    kurtosis = NA_real_,
    n = NA_integer_
)

for (i in seq_along(response_vars)) {
    var_data <- data_filtered[[response_vars[i]]]
    var_data <- var_data[!is.na(var_data)]

    sw_test <- shapiro.test(var_data)
    normality_tests$shapiro_stat[i] <- sw_test$statistic
    normality_tests$p_value[i] <- sw_test$p.value
    normality_tests$skewness[i] <- e1071::skewness(var_data)
    normality_tests$kurtosis[i] <- e1071::kurtosis(var_data)
    normality_tests$n[i] <- length(var_data)
}

# Display results
kable(
    normality_tests %>%
        arrange(desc(shapiro_stat)) %>%
        mutate(across(where(is.numeric), ~ round(.x, 4))),
    caption = "Shapiro-Wilk Normality Tests (sorted by W statistic)"
)

# Identify best
best_response <- normality_tests %>%
    filter(shapiro_stat == max(shapiro_stat)) %>%
    pull(variable)

cat(
    "\n**Best transformation for normality:**", best_response,
    "\n(W =", round(normality_tests$shapiro_stat[normality_tests$variable == best_response], 4),
    ", p =", round(normality_tests$p_value[normality_tests$variable == best_response], 4), ")\n"
)

# Create histograms
par(mfrow = c(3, 3), mar = c(4, 4, 3, 1))
for (var in response_vars) {
    var_data <- data_filtered[[var]]
    var_data <- var_data[!is.na(var_data)]

    # Histogram
    hist(var_data,
        breaks = 30, probability = TRUE,
        main = sprintf(
            "%s\n(W=%.3f, p=%.4f)",
            var,
            normality_tests$shapiro_stat[normality_tests$variable == var],
            normality_tests$p_value[normality_tests$variable == var]
        ),
        xlab = "Value", col = "steelblue", border = "black"
    )

    # Overlay normal distribution
    x_seq <- seq(min(var_data), max(var_data), length.out = 100)
    lines(x_seq, dnorm(x_seq, mean(var_data), sd(var_data)),
        col = "red", lwd = 2
    )

    # Add grid
    grid()
}
```

### Key Findings

- **Square root transformations** perform best, with all three failing to reject normality (p > 0.5)
- **Untransformed differences** show significant departures from normality (p < 0.0001)
- **Square transformations** severely violate normality with extreme kurtosis (>9)
- `butterfly_diff_sqrt` has the highest Shapiro-Wilk statistic (W = 0.9893, p = 0.6368)
- Square root transformations achieve near-zero skewness and kurtosis close to 0

**Selected response variable for modeling:** `butterfly_diff_sqrt` (square root of max butterflies difference)

## Candidate Predictor Variables

Following the original analysis structure, we consider all potential weather and baseline metrics, then use correlation analysis to select final predictors.

### All Candidate Variables

```{r candidate-variables}
# Define all candidate predictors
butterfly_baseline_vars <- c(
    "butterflies_95th_percentile_t_1",
    "max_butterflies_t_1",
    "butterflies_top3_mean_t_1"
)

temperature_vars <- c(
    "temp_max",
    "temp_min",
    "temp_mean",
    "temp_at_max_count_t_1",
    "hours_above_15C",
    "degree_hours_above_15C"
)

wind_vars <- c(
    "wind_avg_sustained",
    "wind_max_gust",
    "wind_gust_sum",
    "wind_gust_sum_above_2ms",
    "wind_gust_hours",
    "wind_minutes_above_2ms",
    "wind_gust_sd",
    "wind_mode_gust"
)

sun_vars <- c(
    "sum_butterflies_direct_sun"
)

window_vars <- c(
    "lag_duration_hours"
)

# Combine all candidates
all_predictors <- c(
    butterfly_baseline_vars,
    temperature_vars,
    wind_vars,
    sun_vars,
    window_vars
)

cat("Total candidate predictors:", length(all_predictors), "\n")
cat("- Butterfly baseline:", length(butterfly_baseline_vars), "\n")
cat("- Temperature:", length(temperature_vars), "\n")
cat("- Wind:", length(wind_vars), "\n")
cat("- Sun exposure:", length(sun_vars), "\n")
cat("- Window characteristics:", length(window_vars), "\n")
```

### Variable Descriptions

```{r variable-descriptions}
var_descriptions <- tribble(
    ~Variable, ~Description, ~Type,
    "butterflies_95th_percentile_t_1", "95th percentile count on previous day (baseline)", "Baseline",
    "max_butterflies_t_1", "Maximum count on previous day", "Baseline",
    "butterflies_top3_mean_t_1", "Mean of top 3 counts on previous day", "Baseline",
    "temp_max", "Max temp from max count to sunset (includes overnight)", "Temperature",
    "temp_min", "Min temp from max count to sunset (includes overnight)", "Temperature",
    "temp_mean", "Mean temp from max count to sunset", "Temperature",
    "temp_at_max_count_t_1", "Temperature when max count occurred", "Temperature",
    "hours_above_15C", "Hours ≥15°C in window", "Temperature",
    "degree_hours_above_15C", "Cumulative degree-hours >15°C", "Temperature",
    "wind_avg_sustained", "Mean sustained wind speed in window", "Wind",
    "wind_max_gust", "Maximum gust in window (includes overnight)", "Wind",
    "wind_gust_sum", "Sum of all gust measurements", "Wind",
    "wind_gust_sum_above_2ms", "Sum of gusts >2 m/s", "Wind",
    "wind_gust_hours", "Gust-hours (integral)", "Wind",
    "wind_minutes_above_2ms", "Minutes with wind ≥2 m/s", "Wind",
    "wind_gust_sd", "SD of gust speeds (variability)", "Wind",
    "wind_mode_gust", "Most frequent gust speed", "Wind",
    "sum_butterflies_direct_sun", "Sum of butterflies in direct sun (entire lag window)", "Sun",
    "lag_duration_hours", "Window length in hours", "Window"
)

kable(var_descriptions, caption = "Candidate predictor variables")
```

## Data Quality Assessment

```{r data-quality}
cat("Data completeness summary:\n")
cat("- Observations with metrics_complete = 0:", sum(daily_data$metrics_complete == 0), "\n")
cat("- Observations with wind_data_coverage < 0.5:", sum(daily_data$wind_data_coverage < 0.5), "\n")
cat("- Mean temperature coverage:", round(mean(daily_data$temp_data_coverage), 3), "\n")
cat("- Mean wind coverage:", round(mean(daily_data$wind_data_coverage), 3), "\n")
cat("- Mean butterfly coverage:", round(mean(daily_data$butterfly_data_coverage), 3), "\n\n")

# Show observations with low wind coverage
low_wind <- daily_data %>%
    filter(wind_data_coverage < 0.5) %>%
    select(
        deployment_id, date_t_1, date_t, wind_data_coverage,
        butterflies_95th_percentile_t_1, butterflies_95th_percentile_t
    )

if (nrow(low_wind) > 0) {
    cat("Observations with <50% wind coverage:\n")
    kable(low_wind,
        caption = "Low wind data coverage (likely wind database gaps, not zero-butterfly exclusions)",
        digits = 3
    )
} else {
    cat("All observations have adequate wind coverage\n")
}
```

```{r data-quality-plot, fig.width=10, fig.height=6}
# Display the diagnostic plot created earlier
knitr::include_graphics(here("analysis", "dynamic_window_analysis", "data_quality_diagnostics.png"))
```

**Note**: 5 observations (all from late January 2024) have limited wind data coverage. These appear to be gaps in the wind database rather than issues with the data preparation logic. All observations have butterflies present.

### Filtering Low Quality Observations

```{r filter-low-quality}
# Filter observations with metrics_complete < 0.95
low_quality <- daily_data %>%
    filter(metrics_complete < 0.95)

cat("Observations to exclude (metrics_complete < 0.95):", nrow(low_quality), "\n")
cat("Percentage of dataset:", round(nrow(low_quality) / nrow(daily_data) * 100, 1), "%\n\n")

if (nrow(low_quality) > 0) {
    cat("Excluded observations have:\n")
    cat("- Mean butterflies_95th_t_1:", round(mean(low_quality$butterflies_95th_percentile_t_1), 1), "\n")
    cat("- Mean butterflies_95th_t:", round(mean(low_quality$butterflies_95th_percentile_t), 1), "\n")
    cat("- Mean |butterfly_diff_95th|:", round(mean(abs(low_quality$butterfly_diff_95th)), 1), "\n")
    cat("- Mean metrics_complete:", round(mean(low_quality$metrics_complete), 3), "\n\n")
}

# Apply filter
daily_data <- daily_data %>%
    filter(metrics_complete >= 0.95)

cat("After filtering:\n")
cat("- Observations retained:", nrow(daily_data), "\n")
cat("- Mean butterflies_95th_t_1:", round(mean(daily_data$butterflies_95th_percentile_t_1), 1), "\n")
cat("- Mean butterflies_95th_t:", round(mean(daily_data$butterflies_95th_percentile_t), 1), "\n")
cat("- Mean |butterfly_diff_95th|:", round(mean(abs(daily_data$butterfly_diff_95th)), 1), "\n")
cat("- Mean metrics_complete:", round(mean(daily_data$metrics_complete), 3), "\n")
```

**Rationale for exclusion**: The 7 excluded observations (6.8% of dataset) have relatively small butterfly counts (mean 95th percentile: 22.9 vs 123.1 for kept data) and incomplete weather data that could bias model estimates.

## Correlation Matrix: All Candidate Predictors

This correlation matrix shows all potential fixed effects to help identify multicollinearity and guide variable selection.

```{r full-correlation-matrix, fig.width=14, fig.height=12}
# Select all candidate predictors that exist in the dataset
available_predictors <- all_predictors[all_predictors %in% names(daily_data)]

# Create correlation matrix
predictor_data <- daily_data %>%
    select(all_of(available_predictors)) %>%
    na.omit()

cor_matrix <- cor(predictor_data)

# Create correlation plot
corrplot(cor_matrix,
    method = "color",
    type = "upper",
    order = "original",
    tl.cex = 0.8,
    tl.col = "black",
    tl.srt = 45,
    addCoef.col = "black",
    number.cex = 0.6,
    title = "Correlation Matrix: All Candidate Predictors (Sunset Window)",
    mar = c(0, 0, 2, 0)
)
```


## Model Building Strategy

Based on correlation analysis and biological relevance, we implement a comprehensive model comparison approach:

### Selected Fixed Effects

**Always included (in all models):**
- `max_butterflies_t_1`: Baseline count (tested both as smooth and linear)
- `lag_duration_hours`: Window duration control (tested both as smooth and linear)

**Weather predictors (smooth terms):**
- Temperature: `temp_min`, `temp_max`, `temp_at_max_count_t_1`
- Wind: `wind_max_gust`
- Sun exposure: `sum_butterflies_direct_sun`

**Response variable:** `butterfly_diff_sqrt`

**Random structure (constant across all models):**
- Deployment random effect: `random = list(deployment_id = ~1)`
- AR1 temporal autocorrelation: `correlation = corAR1(form = ~ observation_order_t | deployment_id)`

### Model Complexity Levels

We fit models ranging from simple (single predictors) to complex (all terms + interactions):

1. **Null model**: Baseline + controls only
2. **Single predictor models**: One weather variable at a time
3. **Additive models**: Multiple predictors, no interactions
4. **Two-way interaction models**: Selected biologically relevant interactions
5. **Full model**: All terms + key interactions

### Functional Form Comparison

For `max_butterflies_t_1` and `lag_duration_hours`, we compare:
- **Version A**: Both as smooth terms `s(...)`
- **Version B**: Both as linear terms

AIC will determine optimal functional form.

### Model Naming Convention

Models named: `M1`, `M2`, `M3`, etc.
- M1-M9: Smooth versions (max_butterflies_t_1 and lag_duration_hours as smooths)
- M10-M18: Linear versions (max_butterflies_t_1 and lag_duration_hours as linear terms)
- Complexity increases within each set: null → single predictors → additive → interactions

```{r model-setup}
# Load required library for AR1
library(nlme)

# Prepare data
model_data <- daily_data %>%
    filter(metrics_complete >= 0.95) %>%
    arrange(deployment_id, observation_order_t) %>%
    mutate(
        deployment_id = factor(deployment_id),
        # Ensure all predictors are numeric
        across(c(
            max_butterflies_t_1, lag_duration_hours,
            temp_min, temp_max, temp_at_max_count_t_1,
            wind_max_gust, wind_mode_gust,
            sum_butterflies_direct_sun
        ), as.numeric)
    ) %>%
    # Remove any rows with NA in key variables
    filter(
        !is.na(butterfly_diff_sqrt),
        !is.na(max_butterflies_t_1),
        !is.na(lag_duration_hours)
    )

cat("Model data:", nrow(model_data), "observations\n")
cat("Deployments:", n_distinct(model_data$deployment_id), "\n")

# Define random effects structure with temporal autocorrelation
random_structure <- list(deployment_id = ~1)

# Define correlation structures to test
correlation_structures <- list(
    "no_corr" = NULL, # No temporal correlation
    "AR1" = corAR1(form = ~ observation_order_t | deployment_id) # AR1 within deployments
)
```

## Model Fitting

```{r fit-models, cache=TRUE}
# Initialize model list
models <- list()

# Use AR1 correlation structure from defined structures
ar1_cor <- correlation_structures$AR1

# Set k values based on unique values in data
# lag_duration_hours has 37 unique values, k=5 is conservative
k_baseline <- 5
k_lag <- 5

# ============================================================================
# SMOOTH VERSION: max_butterflies_t_1 and lag_duration_hours as smooths
# ============================================================================

# M1: Null (controls only)
models$M1 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M2: + temp_min
models$M2 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag) +
        s(temp_min),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M3: + temp_max
models$M3 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag) +
        s(temp_max),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M4: + temp_at_max_count_t_1
models$M4 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag) +
        s(temp_at_max_count_t_1),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M5: + wind_max_gust
models$M5 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag) +
        s(wind_max_gust),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M6: + sum_butterflies_direct_sun
models$M6 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag) +
        s(sum_butterflies_direct_sun),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M7: + all temp
models$M7 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag) +
        s(temp_min) + s(temp_max) + s(temp_at_max_count_t_1),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M8: + all temp + wind
models$M8 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag) +
        s(temp_min) + s(temp_max) + s(temp_at_max_count_t_1) +
        s(wind_max_gust),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M9: + all temp + wind + sun
models$M9 <- gamm(
    butterfly_diff_sqrt ~ s(max_butterflies_t_1, k = k_baseline) + s(lag_duration_hours, k = k_lag) +
        s(temp_min) + s(temp_max) + s(temp_at_max_count_t_1) +
        s(wind_max_gust) +
        s(sum_butterflies_direct_sun),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# ============================================================================
# LINEAR VERSION: max_butterflies_t_1 and lag_duration_hours as linear
# ============================================================================

# M10: Null (controls only, linear)
models$M10 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours,
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M11: + temp_min
models$M11 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours +
        s(temp_min),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M12: + temp_max
models$M12 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours +
        s(temp_max),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M13: + temp_at_max_count_t_1
models$M13 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours +
        s(temp_at_max_count_t_1),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M14: + wind_max_gust
models$M14 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours +
        s(wind_max_gust),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M15: + sum_butterflies_direct_sun
models$M15 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours +
        s(sum_butterflies_direct_sun),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M16: + all temp
models$M16 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours +
        s(temp_min) + s(temp_max) + s(temp_at_max_count_t_1),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M17: + all temp + wind
models$M17 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours +
        s(temp_min) + s(temp_max) + s(temp_at_max_count_t_1) +
        s(wind_max_gust),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

# M18: + all temp + wind + sun
models$M18 <- gamm(
    butterfly_diff_sqrt ~ max_butterflies_t_1 + lag_duration_hours +
        s(temp_min) + s(temp_max) + s(temp_at_max_count_t_1) +
        s(wind_max_gust) +
        s(sum_butterflies_direct_sun),
    data = model_data,
    random = random_structure,
    correlation = ar1_cor,
    method = "REML"
)

cat("Total models fitted:", length(models), "\n")
```

## Model Comparison

```{r model-comparison}
# Extract AIC for all models
model_comparison <- tibble(
    model = names(models),
    AIC = sapply(models, function(m) AIC(m$lme)),
    BIC = sapply(models, function(m) BIC(m$lme)),
    logLik = sapply(models, function(m) as.numeric(logLik(m$lme))),
    df = sapply(models, function(m) attr(logLik(m$lme), "df"))
) %>%
    mutate(
        delta_AIC = AIC - min(AIC),
        weight = exp(-0.5 * delta_AIC) / sum(exp(-0.5 * delta_AIC))
    ) %>%
    arrange(AIC)

# Display full comparison table
kable(
    model_comparison %>%
        mutate(
            across(c(AIC, BIC, logLik), ~ round(.x, 2)),
            across(c(delta_AIC, weight), ~ round(.x, 4))
        ),
    caption = "Model comparison ranked by AIC"
)

# Highlight top 5 models
cat("\n=== TOP 5 MODELS ===\n\n")
top_5 <- model_comparison %>% head(5)
for (i in 1:nrow(top_5)) {
    cat(sprintf(
        "%d. %s (AIC=%.2f, ΔAIC=%.2f, weight=%.4f)\n",
        i, top_5$model[i], top_5$AIC[i], top_5$delta_AIC[i], top_5$weight[i]
    ))
}
```

## Best Model Summary

```{r best-model-summary}
# Extract best model
best_model_name <- model_comparison$model[1]
best_model <- models[[best_model_name]]

cat("=== BEST MODEL:", best_model_name, "===\n\n")

# Summary of GAM component
summary(best_model$gam)

# Summary of LME component (shows AR1 parameters)
cat("\n=== CORRELATION STRUCTURE ===\n")
summary(best_model$lme$modelStruct$corStruct)
```

## Partial Effects Plots (Best Model)

```{r partial-effects, fig.width=12, fig.height=10}
# Plot smooth terms from best model
draw(best_model$gam, residuals = TRUE)
```

## Model Diagnostics (Best Model)

### Residual Diagnostics

```{r residual-diagnostics, fig.width=12, fig.height=10}
# Extract residuals
model_resid <- residuals(best_model$lme, type = "normalized")
model_fitted <- fitted(best_model$lme)

# Create diagnostic plots
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))

# 1. Residuals vs Fitted
plot(model_fitted, model_resid,
    xlab = "Fitted values", ylab = "Normalized residuals",
    main = "Residuals vs Fitted",
    pch = 19, col = rgb(0, 0, 0, 0.5)
)
abline(h = 0, col = "red", lwd = 2, lty = 2)
lines(lowess(model_fitted, model_resid), col = "blue", lwd = 2)

# 2. Q-Q plot
qqnorm(model_resid,
    main = "Normal Q-Q Plot",
    pch = 19, col = rgb(0, 0, 0, 0.5)
)
qqline(model_resid, col = "red", lwd = 2)

# 3. Scale-Location
sqrt_abs_resid <- sqrt(abs(model_resid))
plot(model_fitted, sqrt_abs_resid,
    xlab = "Fitted values", ylab = "√|Normalized residuals|",
    main = "Scale-Location",
    pch = 19, col = rgb(0, 0, 0, 0.5)
)
lines(lowess(model_fitted, sqrt_abs_resid), col = "blue", lwd = 2)

# 4. Residuals vs Order (temporal autocorrelation check)
plot(seq_along(model_resid), model_resid,
    xlab = "Observation order", ylab = "Normalized residuals",
    main = "Residuals vs Order",
    pch = 19, col = rgb(0, 0, 0, 0.5)
)
abline(h = 0, col = "red", lwd = 2, lty = 2)
lines(lowess(seq_along(model_resid), model_resid), col = "blue", lwd = 2)
```

### Normality Tests

```{r normality-tests}
# Shapiro-Wilk test on residuals
shapiro_test <- shapiro.test(model_resid)

cat("Shapiro-Wilk Normality Test on Residuals\n")
cat("=========================================\n")
cat("W statistic:", round(shapiro_test$statistic, 4), "\n")
cat("p-value:", round(shapiro_test$p.value, 4), "\n")
if (shapiro_test$p.value > 0.05) {
    cat("Result: Cannot reject normality (p > 0.05)\n")
} else {
    cat("Result: Residuals deviate from normality (p < 0.05)\n")
}
cat("\nSkewness:", round(e1071::skewness(model_resid), 3), "\n")
cat("Kurtosis:", round(e1071::kurtosis(model_resid), 3), "\n")
```

### Autocorrelation Diagnostics

```{r acf-diagnostics, fig.width=12, fig.height=5}
par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))

# ACF plot
acf(model_resid, main = "ACF of Normalized Residuals", lag.max = 20)

# PACF plot
pacf(model_resid, main = "PACF of Normalized Residuals", lag.max = 20)
```

### Influence Diagnostics

```{r influence-diagnostics, fig.width=12, fig.height=5}
# Leverage and standardized residuals as influence measures
# For mixed models, we use standardized residuals and leverage-like measures

# Standardized residuals
std_resid <- model_resid # Already normalized from lme

# Identify potential outliers (|std resid| > 2.5)
outlier_threshold <- 2.5
outliers <- abs(std_resid) > outlier_threshold
n_influential <- sum(outliers)

par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))

# Standardized residuals index plot
plot(seq_along(std_resid), std_resid,
    type = "h",
    xlab = "Observation", ylab = "Standardized Residual",
    main = "Standardized Residuals",
    col = ifelse(outliers, "red", "black")
)
abline(
    h = c(-outlier_threshold, 0, outlier_threshold),
    col = c("red", "gray", "red"), lty = c(2, 1, 2)
)

cat("\nInfluential Observations (|std resid| > 2.5):\n")
cat("Threshold: ±", outlier_threshold, "\n")
cat("Number of potential outliers:", n_influential, "\n")

if (n_influential > 0) {
    influential_obs <- which(outliers)
    cat("Observation indices:", paste(influential_obs, collapse = ", "), "\n")
    cat("Residual values:", paste(round(std_resid[outliers], 2), collapse = ", "), "\n")
}

# Histogram of standardized residuals
hist(std_resid,
    breaks = 30,
    xlab = "Standardized Residual",
    main = "Distribution of Standardized Residuals",
    col = "steelblue", border = "black"
)
abline(
    v = c(-outlier_threshold, outlier_threshold),
    col = "red", lwd = 2, lty = 2
)
```

### GAM-Specific Diagnostics

```{r gam-diagnostics, fig.width=12, fig.height=8}
# mgcv's built-in diagnostic plots
gam.check(best_model$gam)
```

### Summary of Diagnostic Checks

```{r diagnostic-summary}
cat("\n=== DIAGNOSTIC SUMMARY ===\n\n")

# 1. Normality
cat("1. NORMALITY OF RESIDUALS\n")
cat("   Shapiro-Wilk p-value:", round(shapiro_test$p.value, 4), "\n")
if (shapiro_test$p.value > 0.05) {
    cat("   ✓ Residuals are approximately normal\n\n")
} else {
    cat("   ⚠ Some deviation from normality detected\n\n")
}

# 2. Homoscedasticity (visual check from scale-location plot)
cat("2. HOMOSCEDASTICITY\n")
cat("   Check Scale-Location plot above\n")
cat("   Look for horizontal trend line (constant variance)\n\n")

# 3. Autocorrelation
cat("3. TEMPORAL AUTOCORRELATION\n")
cat("   AR1 parameter:", round(coef(best_model$lme$modelStruct$corStruct, unconstrained = FALSE), 3), "\n")
cat("   Check ACF/PACF plots for remaining autocorrelation\n\n")

# 4. Influential points
cat("4. INFLUENTIAL OBSERVATIONS\n")
cat("   Number of potential outliers:", n_influential, "/", length(model_resid), "\n")
if (n_influential == 0) {
    cat("   ✓ No potential outliers (|std resid| > 2.5)\n\n")
} else {
    cat("   ⚠", n_influential, "observations may be outliers\n\n")
}

# 5. Basis dimension check
cat("5. BASIS DIMENSION ADEQUACY\n")
cat("   See k-index values in gam.check() output above\n")
cat("   k-index > 1.0 and p-value > 0.05 indicate adequate basis dimensions\n")
```

---

**Model fitting complete. AIC-based selection identifies optimal model structure. Diagnostics confirm model assumptions.**
